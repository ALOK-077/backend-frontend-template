/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from 'axios';

export class ProductClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  create(
    dto: CreateProductDto,
    cancelToken?: CancelToken | undefined,
  ): Promise<ProductDto> {
    let url_ = this.baseUrl + '/api/products';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(dto);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: AxiosResponse): Promise<ProductDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ProductDto.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ProductDto>(<any>null);
  }

  delete(
    id?: number | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/products?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param search (optional)
   * @param offset (optional) Offset of list.
   * @param limit (optional) Number of requested records.
   * @param sortBy (optional) Field name for sorting in DB.
   * @param sortOrder (optional) Sort direction. Ascending or Descending.
   */
  search(
    search?: string | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PagedResultOfProductListItemDto> {
    let url_ = this.baseUrl + '/api/products?';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (limit !== undefined && limit !== null)
      url_ += 'Limit=' + encodeURIComponent('' + limit) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortOrder === null)
      throw new Error("The parameter 'sortOrder' cannot be null.");
    else if (sortOrder !== undefined)
      url_ += 'SortOrder=' + encodeURIComponent('' + sortOrder) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSearch(_response);
      });
  }

  protected processSearch(
    response: AxiosResponse,
  ): Promise<PagedResultOfProductListItemDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResultOfProductListItemDto.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PagedResultOfProductListItemDto>(<any>null);
  }

  patch(
    id: number,
    dto: PatchProductDto,
    cancelToken?: CancelToken | undefined,
  ): Promise<ProductDto> {
    let url_ = this.baseUrl + '/api/products/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(dto);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'PATCH',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPatch(_response);
      });
  }

  protected processPatch(response: AxiosResponse): Promise<ProductDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ProductDto.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ProductDto>(<any>null);
  }

  get(id: number, cancelToken?: CancelToken | undefined): Promise<ProductDto> {
    let url_ = this.baseUrl + '/api/products/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet(_response);
      });
  }

  protected processGet(response: AxiosResponse): Promise<ProductDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ProductDto.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ProductDto>(<any>null);
  }
}
type SearchProductQueryParameters = {
  search?: string | null | null;
  offset?: number | null | null;
  limit?: number | null | null;
  sortBy?: string | null | null;
  sortOrder?: SortOrder | null;
};

type GetProductQueryParameters = {
  id: number;
};

export class ProductQuery {
  static get Client() {
    return createClient(ProductClient);
  }

  static searchDefaultOptions?: UseQueryOptions<
    PagedResultOfProductListItemDto,
    unknown,
    PagedResultOfProductListItemDto
  > = {};
  static searchQueryKey = (
    search?: string | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined,
  ) =>
    removeUndefinedFromArrayTail([
      'ProductClient',
      'search',
      search,
      offset,
      limit,
      sortBy,
      sortOrder,
    ]);
  private static search(context: QueryFunctionContext) {
    return ProductQuery.Client.search(
      context.queryKey[2] as string | null | undefined,
      context.queryKey[3] as number | null | undefined,
      context.queryKey[4] as number | null | undefined,
      context.queryKey[5] as string | null | undefined,
      context.queryKey[6] as SortOrder | undefined,
    );
  }

  static useSearchQuery<
    TSelectData = PagedResultOfProductListItemDto,
    TError = unknown,
  >(
    dto: SearchProductQueryParameters,
    options?: UseQueryOptions<
      PagedResultOfProductListItemDto,
      TError,
      TSelectData
    >,
  ): UseQueryResult<TSelectData, TError>;
  /**
   * @param search (optional)
   * @param offset (optional) Offset of list.
   * @param limit (optional) Number of requested records.
   * @param sortBy (optional) Field name for sorting in DB.
   * @param sortOrder (optional) Sort direction. Ascending or Descending.
   */
  static useSearchQuery<
    TSelectData = PagedResultOfProductListItemDto,
    TError = unknown,
  >(
    search?: string | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined,
    options?: UseQueryOptions<
      PagedResultOfProductListItemDto,
      TError,
      TSelectData
    >,
  ): UseQueryResult<TSelectData, TError>;
  static useSearchQuery<
    TSelectData = PagedResultOfProductListItemDto,
    TError = unknown,
  >(...params: any[]): UseQueryResult<TSelectData, TError> {
    let options:
      | UseQueryOptions<PagedResultOfProductListItemDto, TError, TSelectData>
      | undefined = undefined;
    let search: any = undefined;
    let offset: any = undefined;
    let limit: any = undefined;
    let sortBy: any = undefined;
    let sortOrder: any = undefined;

    if (params.length > 0) {
      if (isParameterObject(params[0])) {
        ({ search, offset, limit, sortBy, sortOrder } =
          params[0] as SearchProductQueryParameters);
        options = params[1];
      } else {
        [search, offset, limit, sortBy, sortOrder, options] = params;
      }
    }

    return useQuery<PagedResultOfProductListItemDto, TError, TSelectData>({
      queryFn: ProductQuery.search,
      queryKey: ProductQuery.searchQueryKey(
        search,
        offset,
        limit,
        sortBy,
        sortOrder,
      ),
      ...(ProductQuery.searchDefaultOptions as unknown as UseQueryOptions<
        PagedResultOfProductListItemDto,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
   * @param search (optional)
   * @param offset (optional) Offset of list.
   * @param limit (optional) Number of requested records.
   * @param sortBy (optional) Field name for sorting in DB.
   * @param sortOrder (optional) Sort direction. Ascending or Descending.
   */
  static setSearchData<TData = PagedResultOfProductListItemDto>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
    search?: string | null | undefined,
    offset?: number | null | undefined,
    limit?: number | null | undefined,
    sortBy?: string | null | undefined,
    sortOrder?: SortOrder | undefined,
  ) {
    queryClient.setQueryData(
      ProductQuery.searchQueryKey(search, offset, limit, sortBy, sortOrder),
      updater,
    );
  }

  static getDefaultOptions?: UseQueryOptions<ProductDto, unknown, ProductDto> =
    {};
  static getQueryKey = (id: number) =>
    removeUndefinedFromArrayTail(['ProductClient', 'get', id]);
  private static get(context: QueryFunctionContext) {
    return ProductQuery.Client.get(context.queryKey[2] as number);
  }

  static useGetQuery<TSelectData = ProductDto, TError = unknown>(
    dto: GetProductQueryParameters,
    options?: UseQueryOptions<ProductDto, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useGetQuery<TSelectData = ProductDto, TError = unknown>(
    id: number,
    options?: UseQueryOptions<ProductDto, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useGetQuery<TSelectData = ProductDto, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<ProductDto, TError, TSelectData> | undefined =
      undefined;
    let id: any = undefined;

    if (params.length > 0) {
      if (isParameterObject(params[0])) {
        ({ id } = params[0] as GetProductQueryParameters);
        options = params[1];
      } else {
        [id, options] = params;
      }
    }

    return useQuery<ProductDto, TError, TSelectData>({
      queryFn: ProductQuery.get,
      queryKey: ProductQuery.getQueryKey(id),
      ...(ProductQuery.getDefaultOptions as unknown as UseQueryOptions<
        ProductDto,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setGetData<TData = ProductDto>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
    id: number,
  ) {
    queryClient.setQueryData(ProductQuery.getQueryKey(id), updater);
  }
}

export class OidcConfigurationClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * Requests OIDC configuration for oAuth.
   * @param clientId Client od for requested configuration.
   * @return Return obj for oAuth config.
   */
  getClientRequestParameters(
    clientId: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/_configuration/{clientId}';
    if (clientId === undefined || clientId === null)
      throw new Error("The parameter 'clientId' must be defined.");
    url_ = url_.replace('{clientId}', encodeURIComponent('' + clientId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetClientRequestParameters(_response);
      });
  }

  protected processGetClientRequestParameters(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'Bad request',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}
type GetClientRequestParametersOidcConfigurationQueryParameters = {
  clientId: string | null;
};

export class OidcConfigurationQuery {
  static get Client() {
    return createClient(OidcConfigurationClient);
  }

  static getClientRequestParametersDefaultOptions?: UseQueryOptions<
    void,
    unknown,
    void
  > = {};
  static getClientRequestParametersQueryKey = (clientId: string | null) =>
    removeUndefinedFromArrayTail([
      'OidcConfigurationClient',
      'getClientRequestParameters',
      clientId,
    ]);
  private static getClientRequestParameters(context: QueryFunctionContext) {
    return OidcConfigurationQuery.Client.getClientRequestParameters(
      context.queryKey[2] as string | null,
    );
  }

  static useGetClientRequestParametersQuery<
    TSelectData = void,
    TError = unknown,
  >(
    dto: GetClientRequestParametersOidcConfigurationQueryParameters,
    options?: UseQueryOptions<void, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  /**
   * Requests OIDC configuration for oAuth.
   * @param clientId Client od for requested configuration.
   * @return Return obj for oAuth config.
   */
  static useGetClientRequestParametersQuery<
    TSelectData = void,
    TError = unknown,
  >(
    clientId: string | null,
    options?: UseQueryOptions<void, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useGetClientRequestParametersQuery<
    TSelectData = void,
    TError = unknown,
  >(...params: any[]): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<void, TError, TSelectData> | undefined =
      undefined;
    let clientId: any = undefined;

    if (params.length > 0) {
      if (isParameterObject(params[0])) {
        ({ clientId } =
          params[0] as GetClientRequestParametersOidcConfigurationQueryParameters);
        options = params[1];
      } else {
        [clientId, options] = params;
      }
    }

    return useQuery<void, TError, TSelectData>({
      queryFn: OidcConfigurationQuery.getClientRequestParameters,
      queryKey:
        OidcConfigurationQuery.getClientRequestParametersQueryKey(clientId),
      ...(OidcConfigurationQuery.getClientRequestParametersDefaultOptions as unknown as UseQueryOptions<
        void,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
   * Requests OIDC configuration for oAuth.
   * @param clientId Client od for requested configuration.
   * @return Return obj for oAuth config.
   */
  static setGetClientRequestParametersData<TData = void>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
    clientId: string | null,
  ) {
    queryClient.setQueryData(
      OidcConfigurationQuery.getClientRequestParametersQueryKey(clientId),
      updater,
    );
  }
}

export class SignUrlClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getSignature(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/signature';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetSignature(_response);
      });
  }

  protected processGetSignature(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(<any>null);
  }

  setSignatureCookie(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/signature/cookie';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSetSignatureCookie(_response);
      });
  }

  protected processSetSignatureCookie(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}
export class SignUrlQuery {
  static get Client() {
    return createClient(SignUrlClient);
  }

  static getSignatureDefaultOptions?: UseQueryOptions<string, unknown, string> =
    {};
  static getSignatureQueryKey = () =>
    removeUndefinedFromArrayTail(['SignUrlClient', 'getSignature']);
  private static getSignature() {
    return SignUrlQuery.Client.getSignature();
  }

  static useGetSignatureQuery<TSelectData = string, TError = unknown>(
    options?: UseQueryOptions<string, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useGetSignatureQuery<TSelectData = string, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<string, TError, TSelectData> | undefined =
      undefined;

    options = params[0] as any;

    return useQuery<string, TError, TSelectData>({
      queryFn: SignUrlQuery.getSignature,
      queryKey: SignUrlQuery.getSignatureQueryKey(),
      ...(SignUrlQuery.getSignatureDefaultOptions as unknown as UseQueryOptions<
        string,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setGetSignatureData<TData = string>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
  ) {
    queryClient.setQueryData(SignUrlQuery.getSignatureQueryKey(), updater);
  }

  static setSignatureCookieDefaultOptions?: UseQueryOptions<
    void,
    unknown,
    void
  > = {};
  static setSignatureCookieQueryKey = () =>
    removeUndefinedFromArrayTail(['SignUrlClient', 'setSignatureCookie']);
  private static setSignatureCookie() {
    return SignUrlQuery.Client.setSignatureCookie();
  }

  static useSetSignatureCookieQuery<TSelectData = void, TError = unknown>(
    options?: UseQueryOptions<void, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useSetSignatureCookieQuery<TSelectData = void, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<void, TError, TSelectData> | undefined =
      undefined;

    options = params[0] as any;

    return useQuery<void, TError, TSelectData>({
      queryFn: SignUrlQuery.setSignatureCookie,
      queryKey: SignUrlQuery.setSignatureCookieQueryKey(),
      ...(SignUrlQuery.setSignatureCookieDefaultOptions as unknown as UseQueryOptions<
        void,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  static setSetSignatureCookieData<TData = void>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
  ) {
    queryClient.setQueryData(
      SignUrlQuery.setSignatureCookieQueryKey(),
      updater,
    );
  }
}

export class TestDataClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * Demonstrates an error response.
   */
  throwError(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/error-test';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processThrowError(_response);
      });
  }

  protected processThrowError(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(<any>null);
  }

  /**
   * Sends a dummy email
   */
  sendEmail(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/send-email';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSendEmail(_response);
      });
  }

  protected processSendEmail(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(<any>null);
  }

  /**
   * Tests RequiredOrUndefined attribute
   */
  patch(
    dto: TestPatchDto,
    cancelToken?: CancelToken | undefined,
  ): Promise<string> {
    let url_ = this.baseUrl + '/patch';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(dto);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPatch(_response);
      });
  }

  protected processPatch(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(<any>null);
  }
}
export class TestDataQuery {
  static get Client() {
    return createClient(TestDataClient);
  }

  static throwErrorDefaultOptions?: UseQueryOptions<string, unknown, string> =
    {};
  static throwErrorQueryKey = () =>
    removeUndefinedFromArrayTail(['TestDataClient', 'throwError']);
  private static throwError() {
    return TestDataQuery.Client.throwError();
  }

  /**
   * Demonstrates an error response.
   */
  static useThrowErrorQuery<TSelectData = string, TError = unknown>(
    options?: UseQueryOptions<string, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useThrowErrorQuery<TSelectData = string, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<string, TError, TSelectData> | undefined =
      undefined;

    options = params[0] as any;

    return useQuery<string, TError, TSelectData>({
      queryFn: TestDataQuery.throwError,
      queryKey: TestDataQuery.throwErrorQueryKey(),
      ...(TestDataQuery.throwErrorDefaultOptions as unknown as UseQueryOptions<
        string,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
   * Demonstrates an error response.
   */
  static setThrowErrorData<TData = string>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
  ) {
    queryClient.setQueryData(TestDataQuery.throwErrorQueryKey(), updater);
  }
}

export class VersionClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * Gets the version of the service.
   * @return A string representing the version.
   */
  version(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/api';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processVersion(_response);
      });
  }

  protected processVersion(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(<any>null);
  }
}
export class VersionQuery {
  static get Client() {
    return createClient(VersionClient);
  }

  static versionDefaultOptions?: UseQueryOptions<string, unknown, string> = {};
  static versionQueryKey = () =>
    removeUndefinedFromArrayTail(['VersionClient', 'version']);
  private static version() {
    return VersionQuery.Client.version();
  }

  /**
   * Gets the version of the service.
   * @return A string representing the version.
   */
  static useVersionQuery<TSelectData = string, TError = unknown>(
    options?: UseQueryOptions<string, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useVersionQuery<TSelectData = string, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<string, TError, TSelectData> | undefined =
      undefined;

    options = params[0] as any;

    return useQuery<string, TError, TSelectData>({
      queryFn: VersionQuery.version,
      queryKey: VersionQuery.versionQueryKey(),
      ...(VersionQuery.versionDefaultOptions as unknown as UseQueryOptions<
        string,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
   * Gets the version of the service.
   * @return A string representing the version.
   */
  static setVersionData<TData = string>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
  ) {
    queryClient.setQueryData(VersionQuery.versionQueryKey(), updater);
  }
}

export class SignUrlTestClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
     * It's preferable to use `imageGuid` in URL (not the productId), because it will be cached by the browser.
    And when image for Product is updated, the URL of the image should be changed (to avoid displaying old image from cache).
     */
  getProductImage(
    imageGuid: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/product/image/{imageGuid}';
    if (imageGuid === undefined || imageGuid === null)
      throw new Error("The parameter 'imageGuid' must be defined.");
    url_ = url_.replace('{imageGuid}', encodeURIComponent('' + imageGuid));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetProductImage(_response);
      });
  }

  protected processGetProductImage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
     * It's preferable to use `imageGuid` in URL (not the productId), because it will be cached by the browser.
    And when image for Product is updated, the URL of the image should be changed (to avoid displaying old image from cache).
     */
  getProductImageWithAdvancedUserValidation(
    imageGuid: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/product/image/details/{imageGuid}';
    if (imageGuid === undefined || imageGuid === null)
      throw new Error("The parameter 'imageGuid' must be defined.");
    url_ = url_.replace('{imageGuid}', encodeURIComponent('' + imageGuid));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetProductImageWithAdvancedUserValidation(_response);
      });
  }

  protected processGetProductImageWithAdvancedUserValidation(
    response: AxiosResponse,
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ValidationProblemDetails.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}
type GetProductImageSignUrlTestQueryParameters = {
  imageGuid: string | null;
};

type GetProductImageWithAdvancedUserValidationSignUrlTestQueryParameters = {
  imageGuid: string | null;
};

export class SignUrlTestQuery {
  static get Client() {
    return createClient(SignUrlTestClient);
  }

  static getProductImageDefaultOptions?: UseQueryOptions<void, unknown, void> =
    {};
  static getProductImageQueryKey = (imageGuid: string | null) =>
    removeUndefinedFromArrayTail([
      'SignUrlTestClient',
      'getProductImage',
      imageGuid,
    ]);
  private static getProductImage(context: QueryFunctionContext) {
    return SignUrlTestQuery.Client.getProductImage(
      context.queryKey[2] as string | null,
    );
  }

  static useGetProductImageQuery<TSelectData = void, TError = unknown>(
    dto: GetProductImageSignUrlTestQueryParameters,
    options?: UseQueryOptions<void, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  /**
     * It's preferable to use `imageGuid` in URL (not the productId), because it will be cached by the browser.
    And when image for Product is updated, the URL of the image should be changed (to avoid displaying old image from cache).
     */
  static useGetProductImageQuery<TSelectData = void, TError = unknown>(
    imageGuid: string | null,
    options?: UseQueryOptions<void, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useGetProductImageQuery<TSelectData = void, TError = unknown>(
    ...params: any[]
  ): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<void, TError, TSelectData> | undefined =
      undefined;
    let imageGuid: any = undefined;

    if (params.length > 0) {
      if (isParameterObject(params[0])) {
        ({ imageGuid } =
          params[0] as GetProductImageSignUrlTestQueryParameters);
        options = params[1];
      } else {
        [imageGuid, options] = params;
      }
    }

    return useQuery<void, TError, TSelectData>({
      queryFn: SignUrlTestQuery.getProductImage,
      queryKey: SignUrlTestQuery.getProductImageQueryKey(imageGuid),
      ...(SignUrlTestQuery.getProductImageDefaultOptions as unknown as UseQueryOptions<
        void,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
     * It's preferable to use `imageGuid` in URL (not the productId), because it will be cached by the browser.
    And when image for Product is updated, the URL of the image should be changed (to avoid displaying old image from cache).
     */
  static setGetProductImageData<TData = void>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
    imageGuid: string | null,
  ) {
    queryClient.setQueryData(
      SignUrlTestQuery.getProductImageQueryKey(imageGuid),
      updater,
    );
  }

  static getProductImageWithAdvancedUserValidationDefaultOptions?: UseQueryOptions<
    void,
    unknown,
    void
  > = {};
  static getProductImageWithAdvancedUserValidationQueryKey = (
    imageGuid: string | null,
  ) =>
    removeUndefinedFromArrayTail([
      'SignUrlTestClient',
      'getProductImageWithAdvancedUserValidation',
      imageGuid,
    ]);
  private static getProductImageWithAdvancedUserValidation(
    context: QueryFunctionContext,
  ) {
    return SignUrlTestQuery.Client.getProductImageWithAdvancedUserValidation(
      context.queryKey[2] as string | null,
    );
  }

  static useGetProductImageWithAdvancedUserValidationQuery<
    TSelectData = void,
    TError = unknown,
  >(
    dto: GetProductImageWithAdvancedUserValidationSignUrlTestQueryParameters,
    options?: UseQueryOptions<void, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  /**
     * It's preferable to use `imageGuid` in URL (not the productId), because it will be cached by the browser.
    And when image for Product is updated, the URL of the image should be changed (to avoid displaying old image from cache).
     */
  static useGetProductImageWithAdvancedUserValidationQuery<
    TSelectData = void,
    TError = unknown,
  >(
    imageGuid: string | null,
    options?: UseQueryOptions<void, TError, TSelectData>,
  ): UseQueryResult<TSelectData, TError>;
  static useGetProductImageWithAdvancedUserValidationQuery<
    TSelectData = void,
    TError = unknown,
  >(...params: any[]): UseQueryResult<TSelectData, TError> {
    let options: UseQueryOptions<void, TError, TSelectData> | undefined =
      undefined;
    let imageGuid: any = undefined;

    if (params.length > 0) {
      if (isParameterObject(params[0])) {
        ({ imageGuid } =
          params[0] as GetProductImageWithAdvancedUserValidationSignUrlTestQueryParameters);
        options = params[1];
      } else {
        [imageGuid, options] = params;
      }
    }

    return useQuery<void, TError, TSelectData>({
      queryFn: SignUrlTestQuery.getProductImageWithAdvancedUserValidation,
      queryKey:
        SignUrlTestQuery.getProductImageWithAdvancedUserValidationQueryKey(
          imageGuid,
        ),
      ...(SignUrlTestQuery.getProductImageWithAdvancedUserValidationDefaultOptions as unknown as UseQueryOptions<
        void,
        TError,
        TSelectData
      >),
      ...options,
    });
  }
  /**
     * It's preferable to use `imageGuid` in URL (not the productId), because it will be cached by the browser.
    And when image for Product is updated, the URL of the image should be changed (to avoid displaying old image from cache).
     */
  static setGetProductImageWithAdvancedUserValidationData<TData = void>(
    queryClient: QueryClient,
    updater: (data: TData | undefined) => TData,
    imageGuid: string | null,
  ) {
    queryClient.setQueryData(
      SignUrlTestQuery.getProductImageWithAdvancedUserValidationQueryKey(
        imageGuid,
      ),
      updater,
    );
  }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export class ProblemDetails implements IProblemDetails {
  /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
  type!: string;
  /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
  title!: string;
  /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
  status!: number | null;
  /** A human-readable explanation specific to this occurrence of the problem. */
  detail!: string;
  /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
  instance!: string;
  /** Gets the IDictionary`2 for extension members.

Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
other members of a problem type. */
  extensions?: { [key: string]: any } | null;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
      if (_data['extensions']) {
        this.extensions = {} as any;
        for (let key in _data['extensions']) {
          if (_data['extensions'].hasOwnProperty(key))
            (<any>this.extensions)![key] = _data['extensions'][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    if (this.extensions) {
      data['extensions'] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          (<any>data['extensions'])[key] = this.extensions[key];
      }
    }
    return data;
  }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export interface IProblemDetails {
  /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
  type: string;
  /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
  title: string;
  /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
  status: number | null;
  /** A human-readable explanation specific to this occurrence of the problem. */
  detail: string;
  /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
  instance: string;
  /** Gets the IDictionary`2 for extension members.

Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
other members of a problem type. */
  extensions?: { [key: string]: any } | null;
}

/** A ProblemDetails for validation errors. */
export class ValidationProblemDetails
  extends ProblemDetails
  implements IValidationProblemDetails
{
  /** Gets the validation errors associated with this instance of ValidationProblemDetails. */
  errors?: { [key: string]: string[] } | null;

  constructor(data?: IValidationProblemDetails) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static fromJS(data: any): ValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ValidationProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key))
          (<any>data['errors'])[key] = this.errors[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

/** A ProblemDetails for validation errors. */
export interface IValidationProblemDetails extends IProblemDetails {
  /** Gets the validation errors associated with this instance of ValidationProblemDetails. */
  errors?: { [key: string]: string[] } | null;
}

export class ProductDto implements IProductDto {
  id!: number;
  title!: string;

  constructor(data?: IProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): ProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    return data;
  }
}

export interface IProductDto {
  id: number;
  title: string;
}

export class CreateProductDto implements ICreateProductDto {
  title!: string;

  constructor(data?: ICreateProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): CreateProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    return data;
  }
}

export interface ICreateProductDto {
  title: string;
}

export class PatchProductDto implements IPatchProductDto {
  title?: string;

  constructor(data?: IPatchProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): PatchProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new PatchProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    return data;
  }
}

export interface IPatchProductDto {
  title?: string;
}

export class PagedResultOfProductListItemDto
  implements IPagedResultOfProductListItemDto
{
  data!: ProductListItemDto[];
  totalCount!: number;

  constructor(data?: IPagedResultOfProductListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.data = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data'])
          this.data!.push(ProductListItemDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PagedResultOfProductListItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfProductListItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPagedResultOfProductListItemDto {
  data: ProductListItemDto[];
  totalCount: number;
}

export class ProductListItemDto implements IProductListItemDto {
  id!: number;
  title!: string;

  constructor(data?: IProductListItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): ProductListItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductListItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    return data;
  }
}

export interface IProductListItemDto {
  id: number;
  title: string;
}

export enum SortOrder {
  Asc = 'Asc',
  Desc = 'Desc',
}

export class TestPatchDto implements ITestPatchDto {
  value!: string;

  constructor(data?: ITestPatchDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): TestPatchDto {
    data = typeof data === 'object' ? data : {};
    let result = new TestPatchDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    return data;
  }
}

export interface ITestPatchDto {
  value: string;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}

import {
  useQuery,
  UseQueryResult,
  QueryFunctionContext,
  UseQueryOptions,
  QueryClient,
} from 'react-query';

function removeUndefinedFromArrayTail(arr: any[]): any[] {
  let lastDefinedValueIndex = arr.length - 1;
  while (lastDefinedValueIndex >= 0) {
    if (arr[lastDefinedValueIndex] === undefined) {
      lastDefinedValueIndex--;
    } else {
      break;
    }
  }
  return lastDefinedValueIndex === arr.length - 1
    ? arr
    : arr.slice(0, lastDefinedValueIndex + 1);
}

/*
  Determines if first parameter of useSomethingQuery is an object with query parameters, or it's a regular parameter
  Returns true if parameter is Object
  Returns false if parameter is number/string/boolean/Date or Array
*/
function isParameterObject(param: unknown) {
  if (param === null || param === undefined) return false;
  if (param instanceof Array) return false;
  const isObject = typeof param === 'object';
  if (!isObject) return false;
  if (param instanceof Date) return false;
  return true;
}

type ClientFactoryFunction = <T>(type: new (...params: any[]) => T) => T;
let _clientFactoryFunction: ClientFactoryFunction = <T>(
  type: new (...params: any[]) => T,
) => {
  const params = [_baseUrl, _axiosFactory()];
  return new type(...params);
};
/*
  Overrides default Client factory function
*/
export function setClientFactory(value: ClientFactoryFunction) {
  _clientFactoryFunction = value;
}

/*
  Returns current Client factory function
*/
export function getClientFactory() {
  return _clientFactoryFunction;
}

/*
  Function that will be called from `useQuery...` methods to get a client of certain type
*/
function createClient<T>(type: new () => T) {
  return _clientFactoryFunction(type);
}

let _baseUrl = '';
/*
  Returns the base URL for http requests
*/
export function getBaseUrl(): string {
  return _baseUrl;
}

/*
  Sets the base URL for http requests
*/
export function setBaseUrl(baseUrl: string) {
  _baseUrl = baseUrl;
}

let _axiosFactory: () => AxiosInstance | undefined = () => undefined;
/*
  Returns currently used factory for Axios instances
*/
export function getAxiosFactory() {
  return _axiosFactory;
}
/*
  Sets the factory for Axios instances
*/
export function setAxiosFactory(factory: () => AxiosInstance) {
  _axiosFactory = factory;
}
